'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index-93432d35.js');
var React = require('react');
var React__default = _interopDefault(React);
require('@uploadcare/client-suspense');
var useCustomTabs = require('./use-custom-tabs-3434c5ae.js');
var isEqual = _interopDefault(require('react-fast-compare'));
var uploadcare = _interopDefault(require('uploadcare-widget'));

var useCommitedRef = function useCommitedRef(value) {
  var ref = React.useRef(value);
  React.useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref;
};

var useEventCallback = function useEventCallback(callback) {
  var ref = useCommitedRef(callback);
  return React.useCallback(function () {
    return ref.current && ref.current.apply(ref, arguments);
  }, [ref]);
};

var useValidators = function useValidators(widget, validators) {
  React.useEffect(function () {
    if (validators != null) {
      var instance = widget.current;
      validators.forEach(function (validator) {
        instance.validators.push(validator);
      });
      return function () {
        instance.validators.length = 0;
      };
    }
  }, [widget, validators]);
};

function useDeepMemo(factory, deps) {
  var isValid = true;
  var valueRef = React.useRef(); // initial hook call

  if (!valueRef.current) {
    valueRef.current = {
      deps: deps,
      result: factory()
    }; // subsequent calls
  } else {
    isValid = !!(deps && valueRef.current.deps && isEqual(deps, valueRef.current.deps));
  }

  var cache = isValid ? valueRef.current : {
    deps: deps,
    result: factory()
  }; // must update immediately so any sync renders here don't cause an infinite loop

  valueRef.current = cache;
  return cache.result;
}

function camelCaseToDash(str) {
  return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
}

var propsToAttr = function propsToAttr(props) {
  return Object.entries(props).reduce(function (attr, _ref) {
    var _ref2 = index._slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return index._objectSpread2(index._objectSpread2({}, attr), {}, index._defineProperty({}, "data-".concat(camelCaseToDash(key)), value));
  }, {});
};

var useWidget = function useWidget(_ref3, uploadcare) {
  var id = _ref3.id,
      name = _ref3.name,
      value = _ref3.value,
      onFileSelect = _ref3.onFileSelect,
      onChange = _ref3.onChange,
      onDialogOpen = _ref3.onDialogOpen,
      onDialogClose = _ref3.onDialogClose,
      onTabChange = _ref3.onTabChange,
      apiRef = _ref3.apiRef,
      customTabs = _ref3.customTabs,
      validators = _ref3.validators,
      tabsCss = _ref3.tabsCss,
      options = index._objectWithoutProperties(_ref3, ["id", "name", "value", "onFileSelect", "onChange", "onDialogOpen", "onDialogClose", "onTabChange", "apiRef", "customTabs", "validators", "tabsCss"]);

  var input = React.useRef(null);
  var widget = React.useRef(null);
  var fileSelectedCallback = useEventCallback(onFileSelect);
  var changeCallback = useEventCallback(onChange);
  var dialogOpenCallback = useEventCallback(onDialogOpen);
  var dialogCloseCallback = useEventCallback(onDialogClose);
  var tabChangeCallback = useEventCallback(onTabChange);
  useCustomTabs.useCustomTabs(customTabs, uploadcare);
  var attributes = useDeepMemo(function () {
    return propsToAttr(options);
  }, [options]);
  React.useEffect(function () {
    widget.current = uploadcare.Widget(input.current);
    var widgetElement = input.current.nextSibling;
    return function () {
      return widgetElement && widgetElement.remove();
    };
  }, [uploadcare, attributes]);
  useValidators(widget, validators);
  React.useEffect(function () {
    widget.current.onUploadComplete.add(changeCallback);
    widget.current.onChange.add(fileSelectedCallback);
    return function () {
      widget.current.onUploadComplete.remove(changeCallback);
      widget.current.onChange.remove(fileSelectedCallback);
    };
  }, [changeCallback, fileSelectedCallback]);
  React.useEffect(function () {
    var dialog;

    var saveDialog = function saveDialog(ref) {
      dialog = ref;
      dialog.done(dialogCloseCallback).fail(dialogCloseCallback).progress(tabChangeCallback);
      dialogOpenCallback(ref);
    };

    widget.current.onDialogOpen.add(saveDialog);
    return function () {
      widget.current.onDialogOpen.remove(saveDialog);
      dialog && dialog.reject();
    };
  }, [attributes, dialogCloseCallback, dialogOpenCallback, tabChangeCallback]);
  React.useEffect(function () {
    var files = [];

    var saveFiles = function saveFiles(file) {
      if (file) {
        files = file.files ? file.files() : [file];
      } else {
        files = [];
      }
    };

    widget.current.onChange.add(saveFiles);
    return function () {
      files.forEach(function (file) {
        return file.cancel();
      });
      widget.current.onChange.remove(saveFiles);
    };
  }, [attributes]);
  React.useEffect(function () {
    widget.current.value(value);
  }, [value]);
  React.useEffect(function () {
    if (uploadcare && tabsCss && typeof tabsCss === 'string') {
      if (tabsCss.indexOf('https://') === 0) {
        uploadcare.tabsCss.addUrl(tabsCss);
      } else {
        uploadcare.tabsCss.addStyle(tabsCss);
      }
    }
  }, [uploadcare, tabsCss]);
  React.useImperativeHandle(apiRef, function () {
    return {
      openDialog: function openDialog() {
        return widget.current.openDialog();
      },
      reloadInfo: function reloadInfo() {
        return widget.current.reloadInfo();
      },
      getInput: function getInput() {
        return widget.current.inputElement;
      }
    };
  }, []);
  return React.useCallback(function () {
    return /*#__PURE__*/React__default.createElement("input", index._extends({
      type: "hidden",
      ref: input,
      id: id,
      name: name
    }, attributes));
  }, [attributes, id, name]);
};

var Uploader = function Uploader(props) {
  var Input = useWidget(props, uploadcare);
  return /*#__PURE__*/React__default.createElement(Input, null);
};

exports.default = Uploader;
